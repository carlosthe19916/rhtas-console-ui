// This file is auto-generated by @hey-api/openapi-ts

export type SignArtifactRequest = {
  /**
   * URI or identifier of the artifact to sign. This could be a container image (e.g., quay.io/example/app:latest), a file path, a blob digest, or another unique artifact reference.
   *
   */
  artifact: string;
  /**
   * Type of the artifact to sign. Common types include `container-image`, `file`, `blob`, `sbom`, etc.
   *
   */
  artifactType: "container-image" | "file" | "blob" | "sbom";
  /**
   * OIDC token for Fulcio (if using keyless signing)
   */
  identityToken?: string | null;
  /**
   * Reference to a private key (KMS URI or file)
   */
  privateKeyRef?: string | null;
  /**
   * Optional key-value annotations to include in the signature
   */
  annotations?: {
    [key: string]: string;
  };
};

export type SignArtifactResponse = {
  /**
   * Whether the signing was successful
   */
  success: boolean;
  /**
   * The generated signature
   */
  signature: string;
  /**
   * Fulcio-signed certificate (PEM), if keyless
   */
  certificate?: string | null;
  /**
   * Rekor transparency log entry
   */
  logEntry?: {
    uuid?: string;
    integratedTime?: number;
    logIndex?: number;
  };
};

export type VerifyArtifactRequest = {
  /**
   * URI or identifier of the artifact to verify. This could be a container image (e.g., quay.io/example/app:latest), a file path, a blob digest, or another unique artifact reference.
   *
   */
  artifact: string;
  /**
   * Optional public key path, KMS URI, or URL (for key-based verification)
   */
  publicKey?: string | null;
  /**
   * Path or content of certificate for Fulcio-based verification
   */
  cert?: string | null;
  /**
   * Certificate chain in PEM format (if using keyless verification)
   */
  certChain?: string | null;
  /**
   * Expected identity from Fulcio certificate (OIDC subject)
   */
  certificateIdentity?: string | null;
  /**
   * OIDC issuer for Fulcio verification
   */
  certificateOidcIssuer?: string | null;
  /**
   * Optional key-value annotations to verify in the signature
   */
  annotations?: {
    [key: string]: string;
  };
  /**
   * Whether to run Cosign in offline mode
   */
  offline?: boolean;
  /**
   * Output format
   */
  output?: "json" | "text";
};

export type VerifyArtifactResponse = {
  /**
   * Whether verification was successful
   */
  verified: boolean;
  /**
   * Verification result message
   */
  message: string;
  /**
   * Detailed output from Cosign
   */
  details?: {
    [key: string]: unknown;
  };
};

/**
 * Merkle tree inclusion proof for a Rekor entry
 */
export type InclusionProof = {
  /**
   * Checkpoint string for the log, including tree size and root hash
   */
  checkpoint: string;
  /**
   * Array of Merkle tree hashes for the inclusion proof
   */
  hashes: Array<string>;
  /**
   * Log index of the entry in the Merkle tree
   */
  logIndex: number;
  /**
   * Root hash of the Merkle tree at the time of inclusion
   */
  rootHash: string;
  /**
   * Size of the Merkle tree at the time of inclusion
   */
  treeSize: number;
};

/**
 * Verification details for a Rekor entry, including inclusion proof and signed timestamp
 */
export type Verification = {
  inclusionProof: InclusionProof;
  /**
   * Base64-encoded signed timestamp for the entry
   */
  signedEntryTimestamp: string;
};

export type RekorEntry = {
  /**
   * Unique identifier of the Rekor entry
   */
  uuid: string;
  /**
   * Base64-encoded entry body
   */
  body: string;
  /**
   * Timestamp of when the entry was integrated
   */
  integratedTime: number;
  /**
   * Unique identifier of the transparency log
   */
  logID: string;
  /**
   * Index in the transparency log
   */
  logIndex: number;
  verification: Verification;
};

export type RekorPublicKey = {
  /**
   * Rekor public key in PEM format
   */
  publicKey: string;
};

export type ArtifactPolicies = {
  /**
   * The artifact URI
   */
  artifact: string;
  policies: Array<{
    /**
     * Policy name
     */
    name?: string;
    /**
     * Policy status
     */
    status?: string;
    /**
     * Last time the policy was checked
     */
    lastChecked?: string;
  }>;
  attestations: Array<{
    /**
     * Attestation type
     */
    type?: string;
    /**
     * Issuer of the attestation
     */
    issuer?: string;
    /**
     * Subject of the attestation
     */
    subject?: string;
    /**
     * Issuance timestamp
     */
    issuedAt?: string;
  }>;
};

export type TrustConfig = {
  tufRoot: {
    /**
     * TUF root version
     */
    version: number;
    /**
     * Expiration timestamp
     */
    expires: string;
  };
  fulcioCertAuthorities: Array<{
    /**
     * Certificate authority subject
     */
    subject: string;
    /**
     * Certificate in PEM format
     */
    pem: string;
  }>;
};

export type _Error = {
  /**
   * Error message
   */
  error: string;
};

export type GetHealthzData = {
  body?: never;
  path?: never;
  query?: never;
  url: "/healthz";
};

export type GetHealthzResponses = {
  /**
   * Server is healthy
   */
  200: {
    status?: "ok";
  };
};

export type GetHealthzResponse = GetHealthzResponses[keyof GetHealthzResponses];

export type PostApiV1ArtifactsSignData = {
  body: SignArtifactRequest;
  path?: never;
  query?: never;
  url: "/api/v1/artifacts/sign";
};

export type PostApiV1ArtifactsSignErrors = {
  /**
   * Invalid input
   */
  400: _Error;
  /**
   * Internal server error
   */
  500: _Error;
};

export type PostApiV1ArtifactsSignError = PostApiV1ArtifactsSignErrors[keyof PostApiV1ArtifactsSignErrors];

export type PostApiV1ArtifactsSignResponses = {
  /**
   * Artifact signed successfully
   */
  200: SignArtifactResponse;
};

export type PostApiV1ArtifactsSignResponse = PostApiV1ArtifactsSignResponses[keyof PostApiV1ArtifactsSignResponses];

export type PostApiV1ArtifactsVerifyData = {
  body: VerifyArtifactRequest;
  path?: never;
  query?: never;
  url: "/api/v1/artifacts/verify";
};

export type PostApiV1ArtifactsVerifyErrors = {
  /**
   * Invalid input
   */
  400: _Error;
  /**
   * Verification failed due to internal error
   */
  500: _Error;
};

export type PostApiV1ArtifactsVerifyError = PostApiV1ArtifactsVerifyErrors[keyof PostApiV1ArtifactsVerifyErrors];

export type PostApiV1ArtifactsVerifyResponses = {
  /**
   * Verification succeeded
   */
  200: VerifyArtifactResponse;
};

export type PostApiV1ArtifactsVerifyResponse =
  PostApiV1ArtifactsVerifyResponses[keyof PostApiV1ArtifactsVerifyResponses];

export type GetApiV1RekorEntriesByUuidData = {
  body?: never;
  path: {
    uuid: string;
  };
  query?: never;
  url: "/api/v1/rekor/entries/{uuid}";
};

export type GetApiV1RekorEntriesByUuidErrors = {
  /**
   * Entry not found
   */
  404: _Error;
  /**
   * Internal server error
   */
  500: _Error;
};

export type GetApiV1RekorEntriesByUuidError = GetApiV1RekorEntriesByUuidErrors[keyof GetApiV1RekorEntriesByUuidErrors];

export type GetApiV1RekorEntriesByUuidResponses = {
  /**
   * Rekor entry data
   */
  200: RekorEntry;
};

export type GetApiV1RekorEntriesByUuidResponse =
  GetApiV1RekorEntriesByUuidResponses[keyof GetApiV1RekorEntriesByUuidResponses];

export type GetApiV1RekorPublicKeyData = {
  body?: never;
  path?: never;
  query?: never;
  url: "/api/v1/rekor/public-key";
};

export type GetApiV1RekorPublicKeyErrors = {
  /**
   * Internal server error
   */
  500: _Error;
};

export type GetApiV1RekorPublicKeyError = GetApiV1RekorPublicKeyErrors[keyof GetApiV1RekorPublicKeyErrors];

export type GetApiV1RekorPublicKeyResponses = {
  /**
   * Rekor public key in PEM format
   */
  200: RekorPublicKey;
};

export type GetApiV1RekorPublicKeyResponse = GetApiV1RekorPublicKeyResponses[keyof GetApiV1RekorPublicKeyResponses];

export type GetApiV1ArtifactsByArtifactPoliciesData = {
  body?: never;
  path: {
    artifact: string;
  };
  query?: never;
  url: "/api/v1/artifacts/{artifact}/policies";
};

export type GetApiV1ArtifactsByArtifactPoliciesErrors = {
  /**
   * Artifact not found
   */
  404: _Error;
  /**
   * Internal server error
   */
  500: _Error;
};

export type GetApiV1ArtifactsByArtifactPoliciesError =
  GetApiV1ArtifactsByArtifactPoliciesErrors[keyof GetApiV1ArtifactsByArtifactPoliciesErrors];

export type GetApiV1ArtifactsByArtifactPoliciesResponses = {
  /**
   * Policy and attestation data
   */
  200: ArtifactPolicies;
};

export type GetApiV1ArtifactsByArtifactPoliciesResponse =
  GetApiV1ArtifactsByArtifactPoliciesResponses[keyof GetApiV1ArtifactsByArtifactPoliciesResponses];

export type GetApiV1TrustConfigData = {
  body?: never;
  path?: never;
  query?: never;
  url: "/api/v1/trust/config";
};

export type GetApiV1TrustConfigErrors = {
  /**
   * Internal server error
   */
  500: _Error;
};

export type GetApiV1TrustConfigError = GetApiV1TrustConfigErrors[keyof GetApiV1TrustConfigErrors];

export type GetApiV1TrustConfigResponses = {
  /**
   * Trust root data
   */
  200: TrustConfig;
};

export type GetApiV1TrustConfigResponse = GetApiV1TrustConfigResponses[keyof GetApiV1TrustConfigResponses];

export type ClientOptions = {
  baseURL: "https://api.rhtas.example.com" | (string & {});
};
